//Финская компания имеет большой прямоугольный склад.
//На складе есть рабочий и менеджер.
//Стороны склада в порядке обхода называются левая, верхняя правая, нижняя.
//Площадь склада разбита на квадраты с равной площадью, составляющие строки и столбцы.
//Строки пронумерованы сверху целыми числами 1,2..., а столбцы пронумерованы слева целыми числами 1,2...

//Склад имеет контейнеры, которые используются для хранения отдельных устройств.
//Контейнеры имеют различные идентификационные номера.
//Каждый контейнер занимает ровно один квадрат.
//Склад такой большой, что кол-во контейнеров, которые прибывают, меньше, чем кол-во строк и столбцов.
//Контейнеры не удаляются со склада, но иногда прибывают новые.
//Вход в склад в левом верхнем углу помещения.

//Рабочий разместил контейнеры вокруг левого верхнего угла таким образом, чтобы он мог найти их по их идентицикационным номерам.
//Он использует следующий метод.
//Предположим, что идентификационный номер следующего контейнера, который нужно вставить, есть K.
//Рабочий идёт вдоль первой строки и ищет первый контейнер с идентификационным номером больше, чем К.
//Если он не находит такого контейнера, то он ставит его непосредственно за самым правым контейнером в строке.
//Если такой контейнер L найден, то контейнер L заменяется контейнером К, а контейнер L вставляется в следующую строку при помощи того же самого метода.
//Если рабочий достигает строки, в которой нет ни одного контейнера, он ставит контейнер в позицию самого левого квадрата этой строки.

//Предположим, что контейнеры 3,4,9,2,5,1 прибыли на склад именно в таком порядке.
//Тогда размещение контейнеров на складе будет таким:
//1 4 5
//2 9
//3

//К рабочему подходит менеджер и между ними происходит следующий диалог:
//М: Контейнер 5 прибыл перед контейнером 4?
//Р: Нет, это невозможно.
//М: Так вы можете сказать мне порядок прибытия контейнеров по их размещению?
//Р: Вообще говоря, нет. Например, контейнеры, находящиеся на складе, могли прибыть в порядке 3,2,1,4,9,5 или в порядке 3,2,1,9,4,5 или в одном из 14 других порядков.
//Поскольку менеджер не хочет выглядеть намного глупее рабочего, он уходит.
//Наша задача состоит в том, чтобы помочь менеджеру, написав прогрмму, вычисляющую по данному размещению контейнеров все возможные порядки, в которых они могли пребывать.

//Ввод:
//Первая строка содержит одно целое число - кол-во строк, содержащих контейнеры.
//Следующие R строк содержат информацию о строках 1...R начиная с верхней в следующем порядке:
//В начале каждой из этих строк находится число М целых чисел - идентификационные номера контейнеров в строке, начиная слева.
//Все идентификационные номера контейнеров I удовлетворяют условию 1<=I<=50.
//Число N контейнеров в складе удовлетворяют условию 1<=N<=13.

//Вывод:
//Выходной файл состоит из строк, кол-во которых равно числу различных вариантов прибытия контейнеров.
//Каждая из этих строк содержит N целых чисел - идентификационных номеров контейнеров в порядке, соответствующем порядку прибывания.
//Все строки уникальны (не повторяются).

//Решение:
//Из алгоритма заполнения склада контейнерами следует, что при внесении нового контейнера в складе появляется контейнер на ранее занятой "угловой" позиции, обладающей тем св-вом, что справа от неё и ниже её нет контейнеров.
//Действительно добавляемый контейнер либо сам становится в такую позицию (если его номер больше всех остальных), либо вытесянет в следующую строку контейнер, которому передаёт те же функции; последний делает то же самое и т.д.
//Таким образом, рекурсивно перебирая все "угловые" позиции, обладающие свойством "справа от неё и ниже неё нет контейнеров", и накапливая "выталкиваемые обратно" контейнеры, при освобождении таких позиций мы получим все возможные варианты поступления контейнеров.


program Sklad;
type 
Mas = array[0..13,0..13] of integer; 
Mas1 = array[1..13] of integer;

var
R,i,j,n,k,st,ik: integer; 
s : Mas1; 
a : Mas;

//Процедура Inputdata обеспечивает ввод исходных данных, а рекурсивная процедура Process - формирование (и вывод в файл результата по мере получения) всех возможных порядков поступления контейнеров:
procedure Inputdata;
  begin 
    for var i:=0 to 13 do 
      for var j:=0 to 13 do a[i,j]:=0;
    readln(R);
    for var i:=1 to R do 
      begin 
        read(a[i,0]);
        for var j:=1 to a[i,0] do read(a[i,j]);
      end;
    close(input);
    n:=0; 
  end; 

//Процедура Inputdata формирует в результате ввода двумерный массив А, в котором:
//а[i,0] - кол-во контейнеров в i-й строке
//a[i,j] - номер контейнера, стоящего в i-й строке, j-м столбце (для j от 1 до a[i,0])
//a[i,j]=0 - для позиций, не занятых контейнерами
//R - кол-во строк в массиве А, занятых номерами контейнеров

  procedure Push(st:integer); 
    begin 
      inc(n); s[n]:=st; //порядок выборки элемента по номеру (+1)
    end;
//Добавляет элемент в стек S

  function Pop:integer; 
    begin 
     Pop:=s[n]; s[n]:=0; dec(n); //выборка (теперь -1); элемент достаётся из стека, а его место заменяется на 0
    end; 
//Достаёт элемент из стека S

  procedure PutAnswer; 
    begin 
      write(s[n]); 
       for var j:=n-1 downto 1 do write (' ',s[j]); //выводится возможный порядок поступления контейнеров
      writeln; 
    end;

  procedure Add(var a:mas;k:integer); 
  var i,j,t : integer; 
    begin 
      i:=1; 
      while k<>0 do
        begin 
        j:=1; 
        while ((j<-a[i,0]) and (a[i,j]<k)) 
          do inc(j); 
        if (a[i,0]<>0) and (j<=a[i,0])
          then begin 
            t:=a[i,j]; a[i,j]:=k; 
            k:=t; inc(i);
          end 
        else begin 
          inc(a[i,0]); 
          a[i,a[1,0]]:=k; 
          k:=0; 
        end;
      end; 
    end;
//Добавляет в матрицу а элемент k в соответствии с правилами, описанными в условиях задачи (проверка каждого столбца и строки, начиная с а[1,1]):
//*Рабочий идёт вдоль первой строки и ищет первый контейнер с идентификационным номером больше, чем К. Если он не находит такого контейнера, то он ставит его непосредственно за самым правым контейнером в строке. Если такой контейнер L найден, то контейнер L заменяется контейнером К, а контейнер L вставляется в следующую строку при помощи того же самого метода. Если рабочий достигает строки, в которой нет ни одного контейнера, он ставит контейнер в позицию самого левого квадрата этой строки.*

  procedure Find(var a:mas;i:integer; 
  var k:integer; var ik:integer);
  var j,l,t,x : integer; 
    begin 
      for j:=i downto 1 do 
        begin 
          x:=a[j,0]; 
          for l:=1 to a[j,0] do 
            if (a[j,l]<k) and (a[j,l+1]>k) 
             then x:=l; 
          t:=a[j,x]; a[j,x]:=k; k:=t;
        end;
    end;
//Процедуре Find (a,i,k,ik) передается элемент k, который изменил состояние матрицы, и номер строки i, находящейся непосредственно над строкой с элементом k.
//Процедура Find (a,i,k,ik) находит в матрице а, начиная со строки i, такой элемент k (возвращается такая его строка ik), что при его добавлении матрица а перейдет в состояние, в котором она сейчас находится.
//Для этого в строках с номером j (от i до 1) последовательно выполняется следующая работа:
//1) Находится элемент (a[j,l] или a[j,a[j,0]]), добавление которого в строку j и привело к опусканию элемента k в строку j+1;
//2) Обмениваются значения k и найденного элемента a[j,x]

//Рассмотрим процедуру Process:
  procedure Process(a:mas);
    var i :integer;
    begin 
      if a[1,0]=0 
        then begin PutAnswer; exit; end; 
      for i:=R downto 1 do 
        if (a[i,0]<>0) and (a[i+1,a[i,0]]=0) 
          then
          begin 
            k:=a[i,a[i,0]]; ik:=1;
            Find(a,i-1,k,ik); 
            Push(k); 
            a[ik,a[ik,0]]:=0; dec(a[ik,0]); 
            Process(a); 
            k:=Pop; Add(a,k); 
          end; 
    end;

//Очевидно, что она рекурсивная и что при каждом вызове к ней матрице А становится на 1 элемент меньше.
//Когда матрица а становится пустой (a[1,0]=0), то выводится результат (с помощью пролцедуры PutAnswer) и осуществляется выход из текущего экземпляра рекурсивной процедуры Process.
//Из матрицы а последовательно удаляются все "граничные" элементы видa a[i,a[i,0]] следующим образом:
//С помощью процедуры Find в матрице а находится элемент k, добавление которого привело к заполнению позиции f[i,a[i,0]], ik - номер строки, в которой находится этот элемент.
//Надйенный элемент k заносится в стек с помощью процедуры Push, а его позиция освобождается (a[ik,a[ik,0]]:=0).
//Также уменьшается на 1 счётчик числа элементов в соответсвующей строке (dec(a[ik,0])).
//Таким образом, процедурa Process построила "предыдущую копию" матрицы а до добавления в неё элемента k.
//И теперь вызывает себя вновь - для "уменьшенной" матрицы а.
//После выхода из процедуры Process k восстанавливается из стека функцией Pop, а затем процедурой Add добавляется в матрицу а в соответствии с правилами, описанными в условиях задачи.
//Так обеспечивается рекурсивный обход всех возможных состояний матрицы а, приводящих к её заданному конечному состоянию последовательным добавлением недостающих элементов матрицы а.

begin 
  InputData; 
  assign(output,'depot.out'); rewrite(output);; 
  Process(A);
  close(output);
end.
